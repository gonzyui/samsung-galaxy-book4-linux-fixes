#!/usr/bin/env bash
# camera-relay — On-demand libcamera → v4l2loopback relay for Book5 (IPU7)
# Provides a standard V4L2 device for apps that don't support PipeWire/libcamera.
#
# Usage: camera-relay start|stop|status|enable-persistent|disable-persistent
#        camera-relay start --foreground   (for systemd service use)
#        camera-relay enable-persistent --yes   (skip battery warning prompt)

set -euo pipefail

CARD_LABEL="Camera Relay"
PID_FILE="${XDG_RUNTIME_DIR:-/tmp}/camera-relay.pid"
CACHE_DIR="${XDG_RUNTIME_DIR:-/tmp}"
CAMERA_CACHE="${CACHE_DIR}/camera-relay-camera-name"
DEVICE_CACHE="${CACHE_DIR}/camera-relay-loopback-dev"
SERVICE_DIR="${HOME}/.config/systemd/user"
SERVICE_NAME="camera-relay.service"
LOOPBACK_CONF="/etc/modprobe.d/99-camera-relay-loopback.conf"

# ── Helpers ──────────────────────────────────────────────────────────────────

die() { echo "ERROR: $*" >&2; exit 1; }
info() { echo "[camera-relay] $*"; }
warn() { echo "[camera-relay] WARNING: $*" >&2; }

detect_camera_name() {
    # Check cached name first (avoids camera probing which disrupts active streams)
    if [[ -f "$CAMERA_CACHE" ]]; then
        local cached
        cached=$(cat "$CAMERA_CACHE" 2>/dev/null)
        if [[ -n "$cached" ]]; then
            echo "$cached"
            return 0
        fi
    fi

    # Prefer pw-cli (reads PipeWire metadata, does NOT open the camera).
    # cam -l opens the libcamera CameraManager which disrupts active streams
    # on the Simple pipeline handler (causes image flip/color corruption).
    if command -v pw-cli &>/dev/null; then
        local name
        name=$(pw-cli ls Node 2>/dev/null | grep -oP 'object\.path = "libcamera:\K[^"]+' | head -1)
        if [[ -n "$name" ]]; then
            echo "$name" > "$CAMERA_CACHE"
            echo "$name"
            return 0
        fi
    fi

    # Fallback: cam -l (only safe when no other app is using the camera)
    if command -v cam &>/dev/null; then
        local name
        name=$(cam -l 2>/dev/null | grep -oP "'[^']+'" | head -1 | tr -d "'")
        if [[ -n "$name" ]]; then
            echo "$name" > "$CAMERA_CACHE"
            echo "$name"
            return 0
        fi
    fi

    return 1
}

detect_loopback_device() {
    local dev driver_link
    for dev in /sys/devices/virtual/video4linux/video*/name; do
        [[ -f "$dev" ]] || continue
        # Check if this is a v4l2loopback device by looking at the driver
        driver_link="$(dirname "$dev")/device/driver"
        if [[ -L "$driver_link" ]] && [[ "$(readlink "$driver_link")" == *v4l2loopback* ]]; then
            echo "/dev/$(basename "$(dirname "$dev")")"
            return 0
        fi
        # Fallback: match known v4l2loopback card labels
        local card_name
        card_name=$(cat "$dev" 2>/dev/null)
        case "$card_name" in
            *"Camera Relay"*|*"Loopback"*|*"v4l2loopback"*|*"Intel MIPI Camera"*)
                echo "/dev/$(basename "$(dirname "$dev")")"
                return 0
                ;;
        esac
    done
    return 1
}

ensure_v4l2loopback() {
    # Check if our loopback device already exists
    if detect_loopback_device &>/dev/null; then
        return 0
    fi

    # Check if v4l2loopback module is available
    if ! modinfo v4l2loopback &>/dev/null; then
        die "v4l2loopback kernel module not found. Install it first:
  Fedora:  sudo dnf install v4l2loopback
  Arch:    sudo pacman -S v4l2loopback-dkms
  Ubuntu:  sudo apt install v4l2loopback-dkms"
    fi

    # Try to load it
    info "Loading v4l2loopback module..."
    if [[ -f "$LOOPBACK_CONF" ]]; then
        sudo modprobe v4l2loopback || die "Failed to load v4l2loopback module"
    else
        sudo modprobe v4l2loopback devices=1 exclusive_caps=1 card_label="$CARD_LABEL" \
            || die "Failed to load v4l2loopback module"
    fi

    # Wait briefly for device to appear
    sleep 1

    if ! detect_loopback_device &>/dev/null; then
        die "v4l2loopback loaded but no loopback device found.
Check /etc/modprobe.d/ for v4l2loopback configuration."
    fi
}

is_running() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        # Stale PID file
        rm -f "$PID_FILE"
    fi
    return 1
}

is_persistent() {
    systemctl --user is-enabled "$SERVICE_NAME" &>/dev/null 2>&1
}

detect_ipa_path() {
    # libcamera IPA modules are in <libdir>/libcamera or <libdir>/libcamera/ipa.
    # Check for actual IPA .so files to find the correct path.
    local path
    for path in /usr/lib64/libcamera /usr/lib/libcamera /usr/local/lib/libcamera \
                /lib64/libcamera /lib/libcamera; do
        # Check both the directory itself and ipa/ subdirectory
        if find "$path" -name "*.so" -path "*/ipa/*" 2>/dev/null | grep -q .; then
            echo "$path"
            return 0
        fi
        if find "$path" -maxdepth 1 -name "*.so" 2>/dev/null | grep -q .; then
            echo "$path"
            return 0
        fi
    done
    # Last resort: check environment
    if [[ -n "${LIBCAMERA_IPA_MODULE_PATH:-}" ]]; then
        echo "$LIBCAMERA_IPA_MODULE_PATH"
        return 0
    fi
    return 1
}

# ── Commands ─────────────────────────────────────────────────────────────────

cmd_start() {
    local foreground=false
    [[ "${1:-}" == "--foreground" ]] && foreground=true

    if is_running; then
        local pid
        pid=$(cat "$PID_FILE")
        info "Already running (PID $pid)"
        return 0
    fi

    # Check for libcamerasrc GStreamer element
    if ! gst-inspect-1.0 libcamerasrc &>/dev/null; then
        die "GStreamer 'libcamerasrc' element not found. Install it:
  Fedora:  sudo dnf install gstreamer1-plugins-bad-free-extras
  Arch:    sudo pacman -S gst-plugins-bad
  Ubuntu:  sudo apt install gstreamer1.0-plugins-bad"
    fi

    ensure_v4l2loopback

    local camera_name loopback_dev
    camera_name=$(detect_camera_name) || die "No libcamera device found. Is the camera driver loaded?"
    loopback_dev=$(detect_loopback_device) || die "No v4l2loopback device found"

    # Cache values for passive status checks (systray polls status frequently
    # and any camera/PipeWire probing disrupts the active stream)
    echo "$camera_name" > "$CAMERA_CACHE"
    echo "$loopback_dev" > "$DEVICE_CACHE"

    info "Camera:   $camera_name"
    info "Loopback: $loopback_dev"

    # Set IPA path if available
    local ipa_path
    if ipa_path=$(detect_ipa_path); then
        export LIBCAMERA_IPA_MODULE_PATH="$ipa_path"
    fi

    # gst-launch-1.0 interprets backslashes in property values as escape
    # characters. Camera names like "\_SB_.LNK0" lose the backslash unless
    # we double-escape it. The camera-name property needs the literal "\"
    # to match what libcamera's CameraManager returns.
    local gst_camera_name="${camera_name//\\/\\\\}"

    # Let libcamerasrc negotiate its native format/resolution, then convert.
    # libcamera 0.5.x outputs NV12 via software ISP; 0.7.0+ may use GPU
    # debayering (EGL) which outputs ABGR8888. A queue element is required
    # between source and sink to buffer frames — without it, the async GPU
    # debayer causes "Internal data stream error" (flow error -5).
    # videoconvert handles any input format → YUY2 for v4l2sink.
    # v4l2sink io-mode=1 (MMAP) is required — the default USERPTR mode
    # renders one preroll frame then fails on the PAUSED→PLAYING transition
    # with v4l2loopback (tested on v4l2loopback 0.15.3 / kernel 6.19).
    local gst_cmd=(
        gst-launch-1.0 -e
        libcamerasrc camera-name="$gst_camera_name"
        ! queue max-size-buffers=3 leaky=downstream
        ! videoconvert
        ! "video/x-raw,format=YUY2"
        ! v4l2sink device="$loopback_dev" io-mode=1
    )

    local gst_log="${XDG_RUNTIME_DIR:-/tmp}/camera-relay.log"

    if $foreground; then
        info "Starting relay (foreground)..."
        echo $$ > "$PID_FILE"
        exec "${gst_cmd[@]}"
    else
        info "Starting relay..."
        "${gst_cmd[@]}" >"$gst_log" 2>&1 &
        local pid=$!
        echo "$pid" > "$PID_FILE"

        # Verify it actually started
        sleep 3
        if ! kill -0 "$pid" 2>/dev/null; then
            rm -f "$PID_FILE"
            echo ""
            echo "ERROR: Relay failed to start. GStreamer output:" >&2
            echo "───────────────────────────────────────────────" >&2
            tail -20 "$gst_log" 2>/dev/null >&2 || true
            echo "───────────────────────────────────────────────" >&2
            echo "" >&2
            echo "Common causes:" >&2
            echo "  - Camera in use by another app (Firefox, qcam, etc.)" >&2
            echo "  - v4l2loopback device not ready" >&2
            echo "  - Resolution/format not supported by camera" >&2
            echo "Full log: $gst_log" >&2
            exit 1
        fi

        info "Relay started (PID $pid)"
        local card_name
        card_name=$(cat "/sys/class/video4linux/$(basename "$loopback_dev")/name" 2>/dev/null || echo "$loopback_dev")
        info "Camera available as '$card_name' in apps"
    fi
}

cmd_stop() {
    if ! is_running; then
        info "Not running"
        return 0
    fi

    local pid
    pid=$(cat "$PID_FILE")
    info "Stopping relay (PID $pid)..."

    # Graceful shutdown first (SIGTERM), then force (SIGKILL)
    kill "$pid" 2>/dev/null || true
    local waited=0
    while kill -0 "$pid" 2>/dev/null && (( waited < 5 )); do
        sleep 1
        (( ++waited ))
    done
    if kill -0 "$pid" 2>/dev/null; then
        kill -9 "$pid" 2>/dev/null || true
    fi

    rm -f "$PID_FILE"
    # Keep cache files so status can still show last-known camera/device
    info "Relay stopped"
}

cmd_status() {
    local json=false
    [[ "${1:-}" == "--json" ]] && json=true

    local running=false persistent=false camera="" device=""

    if is_running; then
        running=true
    fi
    if is_persistent; then
        persistent=true
    fi

    # Read from cache files written by cmd_start() — NEVER probe camera or
    # PipeWire here.  The systray polls status every 5 seconds and any
    # libcamera/PipeWire interaction disrupts the active stream (image flip,
    # color corruption on the Simple pipeline handler).
    camera=$(cat "$CAMERA_CACHE" 2>/dev/null) || camera=""
    [[ -z "$camera" ]] && camera="(not detected)"
    device=$(cat "$DEVICE_CACHE" 2>/dev/null) || device=""
    [[ -z "$device" ]] && device="(not loaded)"

    if $json; then
        # Escape backslashes for valid JSON (camera names like \_SB_.LNK0
        # contain literal backslashes that break JSON parsing)
        local json_camera="${camera//\\/\\\\}"
        local json_device="${device//\\/\\\\}"
        printf '{"running":%s,"persistent":%s,"camera":"%s","device":"%s"}\n' \
            "$running" "$persistent" "$json_camera" "$json_device"
    else
        echo "Camera Relay Status"
        echo "─────────────────────"
        if $running; then
            local pid
            pid=$(cat "$PID_FILE" 2>/dev/null)
            echo "  State:      RUNNING (PID $pid)"
        else
            echo "  State:      STOPPED"
        fi
        echo "  Persistent: $( $persistent && echo "ENABLED (auto-starts on login)" || echo "disabled" )"
        echo "  Camera:     $camera"
        echo "  Loopback:   $device"
        if $persistent; then
            echo ""
            echo "  Note: Persistent mode uses ~2-3% extra battery per charge cycle"
        fi
    fi
}

cmd_enable_persistent() {
    local skip_confirm=false
    [[ "${1:-}" == "--yes" ]] && skip_confirm=true

    if is_persistent; then
        info "Persistent mode is already enabled"
        return 0
    fi

    if ! $skip_confirm; then
        echo ""
        echo "  ┌──────────────────────────────────────────────────┐"
        echo "  │           Battery Usage Warning                  │"
        echo "  │                                                  │"
        echo "  │  Persistent mode keeps the camera relay running  │"
        echo "  │  at all times after login. This uses:            │"
        echo "  │                                                  │"
        echo "  │    ~2-3% extra battery per charge cycle          │"
        echo "  │    ~2-3% CPU while active                        │"
        echo "  │                                                  │"
        echo "  │  The relay will auto-start on every login and    │"
        echo "  │  run continuously in the background.             │"
        echo "  │                                                  │"
        echo "  │  You can disable this later with:                │"
        echo "  │    camera-relay disable-persistent               │"
        echo "  └──────────────────────────────────────────────────┘"
        echo ""
        read -rp "  Enable persistent mode? [y/N] " answer
        case "$answer" in
            [yY]|[yY][eE][sS]) ;;
            *) info "Cancelled"; return 1 ;;
        esac
    fi

    # Detect IPA path for the service
    local ipa_path=""
    ipa_path=$(detect_ipa_path 2>/dev/null) || true

    # Create systemd user service
    mkdir -p "$SERVICE_DIR"
    cat > "${SERVICE_DIR}/${SERVICE_NAME}" <<EOF
[Unit]
Description=Camera Relay (libcamera to v4l2loopback)
After=pipewire.service wireplumber.service

[Service]
Type=simple
ExecStart=/usr/local/bin/camera-relay start --foreground
ExecStop=/usr/local/bin/camera-relay stop
Restart=on-failure
RestartSec=5
${ipa_path:+Environment=LIBCAMERA_IPA_MODULE_PATH=$ipa_path}

[Install]
WantedBy=default.target
EOF

    systemctl --user daemon-reload
    systemctl --user enable --now "$SERVICE_NAME"

    info "Persistent mode enabled"
    info "The relay is now running and will auto-start on login"
    info "To disable later: camera-relay disable-persistent"
}

cmd_disable_persistent() {
    if ! is_persistent; then
        info "Persistent mode is not enabled"
        return 0
    fi

    systemctl --user disable --now "$SERVICE_NAME" 2>/dev/null || true
    rm -f "${SERVICE_DIR}/${SERVICE_NAME}"
    systemctl --user daemon-reload

    info "Persistent mode disabled"
    info "The relay will no longer auto-start on login"
}

# ── Main ─────────────────────────────────────────────────────────────────────

usage() {
    cat <<EOF
Usage: camera-relay <command> [options]

Commands:
  start                 Start the camera relay
  start --foreground    Start in foreground (for systemd)
  stop                  Stop the camera relay
  status                Show relay status
  status --json         Show status as JSON
  enable-persistent     Auto-start relay on login (battery warning)
  enable-persistent --yes  Skip confirmation prompt
  disable-persistent    Remove auto-start

The camera relay pipes libcamera output to a v4l2loopback device,
making the camera available to apps that don't support PipeWire
(e.g., Zoom, OBS Studio, VLC).

Note: While the relay is running, PipeWire apps cannot access the
camera directly. Close the relay to use PipeWire apps.
EOF
}

case "${1:-}" in
    start)              cmd_start "${2:-}" ;;
    stop)               cmd_stop ;;
    status)             cmd_status "${2:-}" ;;
    enable-persistent)  cmd_enable_persistent "${2:-}" ;;
    disable-persistent) cmd_disable_persistent ;;
    -h|--help|help)     usage ;;
    *)                  usage; exit 1 ;;
esac
