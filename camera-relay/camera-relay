#!/usr/bin/env bash
# camera-relay — On-demand libcamera → v4l2loopback relay
# Provides a standard V4L2 device for apps that don't support PipeWire/libcamera.
# Works with Book3 (IPU6EP), Book4 (IPU6EP-MTL), and Book5 (IPU7).
#
# In on-demand mode (default for enable-persistent), the relay daemon idles
# with near-zero CPU usage. The camera pipeline only activates when an app
# actually opens the device, and stops when the last app closes it.
#
# Usage: camera-relay start|stop|status|enable-persistent|disable-persistent
#        camera-relay start --foreground   (for systemd service use)
#        camera-relay start --on-demand    (on-demand daemon, foreground)
#        camera-relay enable-persistent --yes   (skip confirmation prompt)

set -euo pipefail

CARD_LABEL="Camera Relay"
PID_FILE="${XDG_RUNTIME_DIR:-/tmp}/camera-relay.pid"
CACHE_DIR="${XDG_RUNTIME_DIR:-/tmp}"
CAMERA_CACHE="${CACHE_DIR}/camera-relay-camera-name"
DEVICE_CACHE="${CACHE_DIR}/camera-relay-loopback-dev"
STATE_CACHE="${CACHE_DIR}/camera-relay-state"
SERVICE_DIR="${HOME}/.config/systemd/user"
SERVICE_NAME="camera-relay.service"
LOOPBACK_CONF="/etc/modprobe.d/99-camera-relay-loopback.conf"
MONITOR_BIN="/usr/local/bin/camera-relay-monitor"

# ── Helpers ──────────────────────────────────────────────────────────────────

die() { echo "ERROR: $*" >&2; exit 1; }
info() { echo "[camera-relay] $*"; }
warn() { echo "[camera-relay] WARNING: $*" >&2; }

detect_camera_name() {
    # Check cached name first (avoids camera probing which disrupts active streams)
    if [[ -f "$CAMERA_CACHE" ]]; then
        local cached
        cached=$(cat "$CAMERA_CACHE" 2>/dev/null)
        if [[ -n "$cached" ]]; then
            echo "$cached"
            return 0
        fi
    fi

    # Prefer pw-cli (reads PipeWire metadata, does NOT open the camera).
    # cam -l opens the libcamera CameraManager which disrupts active streams
    # on the Simple pipeline handler (causes image flip/color corruption).
    # Filter out USB cameras (XHCI path) — we want the internal MIPI camera.
    if command -v pw-cli &>/dev/null; then
        local name
        name=$(pw-cli ls Node 2>/dev/null \
            | grep -oP 'object\.path = "libcamera:\K[^"]+' \
            | grep -v 'XHCI' \
            | head -1)
        if [[ -n "$name" ]]; then
            echo "$name" > "$CAMERA_CACHE"
            echo "$name"
            return 0
        fi
    fi

    # Fallback: cam -l (only safe when no other app is using the camera)
    # Output format: "1: 'ov02c10' (\_SB_.PC00.LNK0)"
    # Extract the camera ID from parentheses — this is what gst-launch needs
    # for the camera-name property (not the display name in quotes).
    if command -v cam &>/dev/null; then
        local name
        name=$(cam -l 2>/dev/null | grep -oP '\(([^)]+)\)' | head -1 | tr -d '()')
        if [[ -n "$name" ]]; then
            echo "$name" > "$CAMERA_CACHE"
            echo "$name"
            return 0
        fi
        # Fallback to quoted display name if no parenthesized ID
        name=$(cam -l 2>/dev/null | grep -oP "'[^']+'" | head -1 | tr -d "'")
        if [[ -n "$name" ]]; then
            echo "$name" > "$CAMERA_CACHE"
            echo "$name"
            return 0
        fi
    fi

    return 1
}

detect_loopback_device() {
    local dev driver_link
    for dev in /sys/devices/virtual/video4linux/video*/name; do
        [[ -f "$dev" ]] || continue
        # Check if this is a v4l2loopback device by looking at the driver
        driver_link="$(dirname "$dev")/device/driver"
        if [[ -L "$driver_link" ]] && [[ "$(readlink "$driver_link")" == *v4l2loopback* ]]; then
            echo "/dev/$(basename "$(dirname "$dev")")"
            return 0
        fi
        # Fallback: match known v4l2loopback card labels
        local card_name
        card_name=$(cat "$dev" 2>/dev/null)
        case "$card_name" in
            *"Camera Relay"*|*"Loopback"*|*"v4l2loopback"*|*"Intel MIPI Camera"*)
                echo "/dev/$(basename "$(dirname "$dev")")"
                return 0
                ;;
        esac
    done
    return 1
}

ensure_v4l2loopback() {
    # Check if our loopback device already exists
    if detect_loopback_device &>/dev/null; then
        return 0
    fi

    # Check if v4l2loopback module is available
    if ! modinfo v4l2loopback &>/dev/null; then
        die "v4l2loopback kernel module not found. Install it first:
  Fedora:  sudo dnf install v4l2loopback
  Arch:    sudo pacman -S v4l2loopback-dkms
  Ubuntu:  sudo apt install v4l2loopback-dkms"
    fi

    # Try to load it
    info "Loading v4l2loopback module..."
    if [[ -f "$LOOPBACK_CONF" ]]; then
        sudo modprobe v4l2loopback || die "Failed to load v4l2loopback module"
    else
        sudo modprobe v4l2loopback devices=1 exclusive_caps=0 card_label="$CARD_LABEL" \
            || die "Failed to load v4l2loopback module"
    fi

    # Wait briefly for device to appear
    sleep 1

    if ! detect_loopback_device &>/dev/null; then
        die "v4l2loopback loaded but no loopback device found.
Check /etc/modprobe.d/ for v4l2loopback configuration."
    fi
}

is_running() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        # Stale PID file
        rm -f "$PID_FILE"
    fi
    return 1
}

is_persistent() {
    systemctl --user is-enabled "$SERVICE_NAME" &>/dev/null 2>&1
}

detect_gst_plugin_path() {
    local dir
    for dir in /usr/local/lib/x86_64-linux-gnu/gstreamer-1.0 \
               /usr/local/lib64/gstreamer-1.0 \
               /usr/local/lib/gstreamer-1.0 \
               /usr/local/lib/aarch64-linux-gnu/gstreamer-1.0; do
        if [[ -f "$dir/libgstlibcamera.so" ]]; then
            echo "$dir"
            return 0
        fi
    done
    return 1
}

detect_ipa_path() {
    local path
    for path in /usr/lib64/libcamera /usr/lib/libcamera /usr/local/lib/libcamera \
                /lib64/libcamera /lib/libcamera; do
        if find "$path" -name "*.so" -path "*/ipa/*" 2>/dev/null | grep -q .; then
            echo "$path"
            return 0
        fi
        if find "$path" -maxdepth 1 -name "*.so" 2>/dev/null | grep -q .; then
            echo "$path"
            return 0
        fi
    done
    if [[ -n "${LIBCAMERA_IPA_MODULE_PATH:-}" ]]; then
        echo "$LIBCAMERA_IPA_MODULE_PATH"
        return 0
    fi
    return 1
}

setup_environment() {
    # GStreamer plugin path
    local gst_extra_path
    if gst_extra_path=$(detect_gst_plugin_path); then
        export GST_PLUGIN_PATH="${gst_extra_path}${GST_PLUGIN_PATH:+:$GST_PLUGIN_PATH}"
        info "Using GStreamer plugin: $gst_extra_path"
    fi

    # Check for libcamerasrc
    if ! gst-inspect-1.0 libcamerasrc &>/dev/null; then
        die "GStreamer 'libcamerasrc' element not found. Install it:
  Fedora:  sudo dnf install gstreamer1-plugins-bad-free-extras
  Arch:    sudo pacman -S gst-plugins-bad
  Ubuntu:  sudo apt install gstreamer1.0-plugins-bad"
    fi

    # IPA path
    local ipa_path
    if ipa_path=$(detect_ipa_path); then
        export LIBCAMERA_IPA_MODULE_PATH="$ipa_path"
    fi
}

# Start the GStreamer pipeline, return its PID.
# videoflip method=none: Critical workaround for libcamera 0.7.0+ GPU ISP.
# Forces a CPU-side pixel copy that materializes DMA-BUF data into
# system memory, fixing black frames through v4l2loopback.
# In fast mode (for on-demand), skip the 3s verification sleep.
start_pipeline() {
    local camera_name="$1"
    local loopback_dev="$2"
    local fast="${3:-false}"
    local gst_log="${XDG_RUNTIME_DIR:-/tmp}/camera-relay-gst.log"

    # gst-launch-1.0 interprets backslashes as escape characters.
    # Camera names like "\_SB_.LNK0" need double-escaping.
    local gst_camera_name="${camera_name//\\/\\\\}"

    local -a gst_cmd=(
        gst-launch-1.0 -e
        libcamerasrc camera-name="$gst_camera_name"
        ! queue max-size-buffers=3 leaky=downstream
        ! videoflip method=none
        ! videoconvert
        ! "video/x-raw,format=YUY2"
        ! v4l2sink device="$loopback_dev" sync=false
    )

    "${gst_cmd[@]}" >"$gst_log" 2>&1 &
    local pid=$!

    if $fast; then
        sleep 0.5
        if ! kill -0 "$pid" 2>/dev/null; then
            gst_cmd=(
                gst-launch-1.0 -e
                libcamerasrc camera-name="$gst_camera_name"
                ! queue max-size-buffers=3 leaky=downstream
                ! videoflip method=none
                ! videoconvert
                ! "video/x-raw,format=YUY2"
                ! v4l2sink device="$loopback_dev" io-mode=1 sync=false
            )
            "${gst_cmd[@]}" >"$gst_log" 2>&1 &
            pid=$!
            sleep 0.5
        fi
    else
        sleep 3
        if ! kill -0 "$pid" 2>/dev/null; then
            info "Default io-mode failed, retrying with MMAP (io-mode=1)..."
            gst_cmd=(
                gst-launch-1.0 -e
                libcamerasrc camera-name="$gst_camera_name"
                ! queue max-size-buffers=3 leaky=downstream
                ! videoflip method=none
                ! videoconvert
                ! "video/x-raw,format=YUY2"
                ! v4l2sink device="$loopback_dev" io-mode=1 sync=false
            )
            "${gst_cmd[@]}" >"$gst_log" 2>&1 &
            pid=$!
            sleep 3
        fi
    fi

    if ! kill -0 "$pid" 2>/dev/null; then
        warn "Pipeline failed to start. Log: $gst_log"
        return 1
    fi

    echo "$pid"
    return 0
}

stop_pipeline() {
    local pid="$1"
    kill "$pid" 2>/dev/null || true
    local waited=0
    while kill -0 "$pid" 2>/dev/null && (( waited < 5 )); do
        sleep 1
        (( ++waited ))
    done
    if kill -0 "$pid" 2>/dev/null; then
        kill -9 "$pid" 2>/dev/null || true
    fi
}

nudge_wireplumber() {
    local loopback_dev="$1"
    if command -v udevadm &>/dev/null && command -v systemctl &>/dev/null; then
        sudo udevadm trigger --action=change "$loopback_dev" 2>/dev/null || true
        sleep 1
        systemctl --user restart wireplumber 2>/dev/null || true
    fi
}

# ── Commands ─────────────────────────────────────────────────────────────────

cmd_start() {
    local mode="${1:-}"

    if [[ "$mode" == "--on-demand" ]]; then
        cmd_start_on_demand
        return
    fi

    local foreground=false
    [[ "$mode" == "--foreground" ]] && foreground=true

    if is_running; then
        local pid
        pid=$(cat "$PID_FILE")
        info "Already running (PID $pid)"
        return 0
    fi

    setup_environment
    ensure_v4l2loopback

    local camera_name loopback_dev
    camera_name=$(detect_camera_name) || die "No libcamera device found. Is the camera driver loaded?"
    loopback_dev=$(detect_loopback_device) || die "No v4l2loopback device found"

    echo "$camera_name" > "$CAMERA_CACHE"
    echo "$loopback_dev" > "$DEVICE_CACHE"

    info "Camera:   $camera_name"
    info "Loopback: $loopback_dev"

    local gst_log="${XDG_RUNTIME_DIR:-/tmp}/camera-relay.log"

    if $foreground; then
        info "Starting relay (foreground)..."
        echo "streaming" > "$STATE_CACHE"
        echo $$ > "$PID_FILE"
        local gst_camera_name="${camera_name//\\/\\\\}"
        exec gst-launch-1.0 -e \
            libcamerasrc camera-name="$gst_camera_name" \
            ! queue max-size-buffers=3 leaky=downstream \
            ! videoflip method=none \
            ! videoconvert \
            ! "video/x-raw,format=YUY2" \
            ! v4l2sink device="$loopback_dev" sync=false
    else
        info "Starting relay..."
        local pid
        pid=$(start_pipeline "$camera_name" "$loopback_dev" false) || true

        if [[ -z "$pid" ]] || ! kill -0 "$pid" 2>/dev/null; then
            echo "" >&2
            echo "ERROR: Relay failed to start. GStreamer output:" >&2
            echo "───────────────────────────────────────────────" >&2
            tail -20 "$gst_log" 2>/dev/null >&2 || true
            echo "───────────────────────────────────────────────" >&2
            echo "" >&2
            echo "Common causes:" >&2
            echo "  - Camera in use by another app (Firefox, qcam, etc.)" >&2
            echo "  - v4l2loopback device not ready" >&2
            echo "  - Resolution/format not supported by camera" >&2
            echo "Full log: $gst_log" >&2
            exit 1
        fi

        echo "$pid" > "$PID_FILE"
        echo "streaming" > "$STATE_CACHE"
        info "Relay started (PID $pid)"
        local card_name
        card_name=$(cat "/sys/class/video4linux/$(basename "$loopback_dev")/name" 2>/dev/null || echo "$loopback_dev")
        info "Camera available as '$card_name' in apps"

        nudge_wireplumber "$loopback_dev"
    fi
}

cmd_start_on_demand() {
    if is_running; then
        local pid
        pid=$(cat "$PID_FILE")
        info "Already running (PID $pid)"
        return 0
    fi

    setup_environment
    ensure_v4l2loopback

    local camera_name loopback_dev
    camera_name=$(detect_camera_name) || die "No libcamera device found. Is the camera driver loaded?"
    loopback_dev=$(detect_loopback_device) || die "No v4l2loopback device found"

    echo "$camera_name" > "$CAMERA_CACHE"
    echo "$loopback_dev" > "$DEVICE_CACHE"

    info "Camera:   $camera_name"
    info "Loopback: $loopback_dev"

    # Check for monitor binary
    if [[ ! -x "$MONITOR_BIN" ]]; then
        die "camera-relay-monitor not found at $MONITOR_BIN.
Run the installer to build it, or use 'camera-relay start' for always-on mode."
    fi

    echo $$ > "$PID_FILE"
    echo "idle" > "$STATE_CACHE"

    info "Starting on-demand relay daemon..."
    info "Camera pipeline will activate when an app opens the device"

    local pipeline_pid=""
    local gst_log="${XDG_RUNTIME_DIR:-/tmp}/camera-relay.log"

    # Clean up all children on exit (monitor runs in process substitution)
    cleanup_on_demand() {
        [[ -n "$pipeline_pid" ]] && kill "$pipeline_pid" 2>/dev/null
        pkill -P $$ 2>/dev/null  # kill monitor and any other children
        rm -f "$PID_FILE" "$STATE_CACHE"
    }
    trap cleanup_on_demand EXIT

    # Read events from the monitor. It emits: READY, START, STOP
    while IFS= read -r event; do
        case "$event" in
            READY)
                info "Monitor ready, device visible to apps"
                (nudge_wireplumber "$loopback_dev") &
                ;;
            START)
                if [[ -z "$pipeline_pid" ]] || ! kill -0 "$pipeline_pid" 2>/dev/null; then
                    info "Client connected — starting camera pipeline..."
                    echo "streaming" > "$STATE_CACHE"
                    pipeline_pid=$(start_pipeline "$camera_name" "$loopback_dev" true) || {
                        warn "Failed to start pipeline"
                        pipeline_pid=""
                        echo "idle" > "$STATE_CACHE"
                        continue
                    }
                    info "Pipeline started (PID $pipeline_pid)"
                fi
                ;;
            STOP)
                if [[ -n "$pipeline_pid" ]] && kill -0 "$pipeline_pid" 2>/dev/null; then
                    info "All clients disconnected — stopping camera pipeline"
                    stop_pipeline "$pipeline_pid"
                    pipeline_pid=""
                    echo "idle" > "$STATE_CACHE"
                    info "Pipeline stopped, camera released"
                fi
                ;;
        esac
    done < <("$MONITOR_BIN" "$loopback_dev" 1920 1080 2>"$gst_log")

    info "On-demand relay stopped"
}

cmd_stop() {
    if ! is_running; then
        info "Not running"
        return 0
    fi

    local pid
    pid=$(cat "$PID_FILE")
    info "Stopping relay (PID $pid)..."

    kill "$pid" 2>/dev/null || true
    local waited=0
    while kill -0 "$pid" 2>/dev/null && (( waited < 5 )); do
        sleep 1
        (( ++waited ))
    done
    if kill -0 "$pid" 2>/dev/null; then
        kill -9 "$pid" 2>/dev/null || true
    fi

    # Also kill any child gst-launch processes
    pkill -P "$pid" 2>/dev/null || true

    rm -f "$PID_FILE" "$STATE_CACHE"
    info "Relay stopped"
}

cmd_status() {
    local json=false
    [[ "${1:-}" == "--json" ]] && json=true

    local running=false persistent=false camera="" device="" state="stopped"

    if is_running; then
        running=true
    fi
    if is_persistent; then
        persistent=true
    fi

    camera=$(cat "$CAMERA_CACHE" 2>/dev/null) || camera=""
    [[ -z "$camera" ]] && camera="(not detected)"
    device=$(cat "$DEVICE_CACHE" 2>/dev/null) || device=""
    [[ -z "$device" ]] && device="(not loaded)"
    state=$(cat "$STATE_CACHE" 2>/dev/null) || state="stopped"
    $running || state="stopped"

    if $json; then
        local json_camera="${camera//\\/\\\\}"
        local json_device="${device//\\/\\\\}"
        printf '{"running":%s,"persistent":%s,"camera":"%s","device":"%s","state":"%s"}\n' \
            "$running" "$persistent" "$json_camera" "$json_device" "$state"
    else
        echo "Camera Relay Status"
        echo "─────────────────────"
        if $running; then
            local pid
            pid=$(cat "$PID_FILE" 2>/dev/null)
            if [[ "$state" == "idle" ]]; then
                echo "  State:      ON-DEMAND (idle, PID $pid)"
            else
                echo "  State:      STREAMING (PID $pid)"
            fi
        else
            echo "  State:      STOPPED"
        fi
        echo "  Persistent: $( $persistent && echo "ENABLED (on-demand, auto-starts on login)" || echo "disabled" )"
        echo "  Camera:     $camera"
        echo "  Loopback:   $device"
    fi
}

cmd_enable_persistent() {
    local skip_confirm=false
    [[ "${1:-}" == "--yes" ]] && skip_confirm=true

    if is_persistent; then
        info "Persistent mode is already enabled"
        return 0
    fi

    if ! $skip_confirm; then
        echo ""
        echo "  ┌──────────────────────────────────────────────────┐"
        echo "  │           On-Demand Camera Relay                 │"
        echo "  │                                                  │"
        echo "  │  The relay daemon will start on login and wait   │"
        echo "  │  for apps to use the camera. Resource usage:     │"
        echo "  │                                                  │"
        echo "  │    Idle:      Near-zero CPU and battery          │"
        echo "  │    Streaming: ~2-3% CPU (only while in use)      │"
        echo "  │                                                  │"
        echo "  │  The camera activates automatically when apps    │"
        echo "  │  like Zoom or Chrome open the camera device,     │"
        echo "  │  and deactivates when they close it.             │"
        echo "  │                                                  │"
        echo "  │  You can disable this later with:                │"
        echo "  │    camera-relay disable-persistent               │"
        echo "  └──────────────────────────────────────────────────┘"
        echo ""
        read -rp "  Enable on-demand camera relay? [y/N] " answer
        case "$answer" in
            [yY]|[yY][eE][sS]) ;;
            *) info "Cancelled"; return 1 ;;
        esac
    fi

    # Detect paths for the service environment
    local ipa_path="" gst_path=""
    ipa_path=$(detect_ipa_path 2>/dev/null) || true
    gst_path=$(detect_gst_plugin_path 2>/dev/null) || true

    # Create systemd user service
    mkdir -p "$SERVICE_DIR"
    cat > "${SERVICE_DIR}/${SERVICE_NAME}" <<EOF
[Unit]
Description=Camera Relay (on-demand libcamera to v4l2loopback)
After=pipewire.service wireplumber.service

[Service]
Type=simple
ExecStart=/usr/local/bin/camera-relay start --on-demand
ExecStop=/usr/local/bin/camera-relay stop
Restart=on-failure
RestartSec=5
${ipa_path:+Environment=LIBCAMERA_IPA_MODULE_PATH=$ipa_path}
${gst_path:+Environment=GST_PLUGIN_PATH=$gst_path}

[Install]
WantedBy=default.target
EOF

    systemctl --user daemon-reload
    systemctl --user enable --now "$SERVICE_NAME"

    info "On-demand relay enabled"
    info "The camera device is now visible to apps and will activate on use"
    info "To disable later: camera-relay disable-persistent"
}

cmd_disable_persistent() {
    if ! is_persistent; then
        info "Persistent mode is not enabled"
        return 0
    fi

    systemctl --user disable --now "$SERVICE_NAME" 2>/dev/null || true
    rm -f "${SERVICE_DIR}/${SERVICE_NAME}"
    systemctl --user daemon-reload

    info "Persistent mode disabled"
    info "The relay will no longer auto-start on login"
}

# ── Main ─────────────────────────────────────────────────────────────────────

usage() {
    cat <<EOF
Usage: camera-relay <command> [options]

Commands:
  start                 Start the camera relay (always-on streaming)
  start --on-demand     Start on-demand daemon (activates on app use)
  start --foreground    Start always-on relay in foreground (for systemd)
  stop                  Stop the camera relay
  status                Show relay status
  status --json         Show status as JSON
  enable-persistent     Auto-start on-demand relay on login
  enable-persistent --yes  Skip confirmation prompt
  disable-persistent    Remove auto-start

The camera relay provides a standard V4L2 webcam device for apps that
don't support PipeWire/libcamera (e.g., Zoom, OBS Studio, VLC).

In on-demand mode (default for persistent), the daemon idles with
near-zero resource usage. The camera only activates when an app
opens the device, and stops when the last app closes it.
EOF
}

case "${1:-}" in
    start)              cmd_start "${2:-}" ;;
    stop)               cmd_stop ;;
    status)             cmd_status "${2:-}" ;;
    enable-persistent)  cmd_enable_persistent "${2:-}" ;;
    disable-persistent) cmd_disable_persistent ;;
    -h|--help|help)     usage ;;
    *)                  usage; exit 1 ;;
esac
